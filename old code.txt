        function qEnd = MoveRobot(robot, pose, steps, object, vertices, pickUp, endEffDirection, g1, g2, grip)
            % MoveRobot Moves a robot to a specified position and operates the gripper.
            %
            % Inputs:
            %   - robot: The robot model.
            %   - position: Desired end-effector position.
            %   - steps: Number of steps for the trajectory.
            %   - payload: The graphical object to update.
            %   - holdingObject: Boolean indicating if the robot is holding the object.
            %   - vertices: Vertices of the object.
            %   - endEffDirection: End-effector direction setting.
            %   - g_1, g_2: Gripper models.
            %   - grip: Gripper state (1 for close, 2 for open).
            %
            % Outputs:
            %   - qEnd: Final joint configuration.
        
            % Determine the end-effector pose based on direction.
            switch lower(endEffDirection)
                case 'left'
                    endMove = transl(pose) * troty(pi/2);
                case 'right'
                    endMove = transl(pose) * troty(-pi/2);
                case 'forward'
                    endMove = transl(pose); % No rotation, points along positive x-axis
                case 'down'
                    endMove = transl(pose) * trotx(pi); % End effector points downwards
                otherwise
                    error('Invalid endEffDirection. Use "left", "right", "forward", or "down".');
            end
        
            q0 = robot.model.getpos();
            q1 = robot.model.ikcon(robot.model.fkine(q0), q0);
            q2 = robot.model.ikcon(endMove, q0);
        
            % Generate trajectory using trapezoidal velocity profile.
            s = lspb(0, 1, steps);
            qMatrix = (1 - s)' * q1 + s' * q2;
        
            % Setup gripper trajectories if required.
            if grip == 1
                qPath1 = jtraj([0, 0, 0], [deg2rad(30), -deg2rad(30), 0], steps);
                qPath2 = jtraj([0, 0, 0], [-deg2rad(30), deg2rad(30), 0], steps);
            elseif grip == 2
                qPath1 = jtraj([deg2rad(30), -deg2rad(30), 0], [0, 0, 0], steps);
                qPath2 = jtraj([-deg2rad(30), deg2rad(30), 0], [0, 0, 0], steps);
            end
        
            % Execute the motion and animate the robot and grippers.
            for i = 1:steps
                robot.model.animate(qMatrix(i, :));
        
                % Update gripper positions.
                pos1 = robot.model.fkine(qMatrix(i, :)) * transl(0, -0.0127, 0.05) * troty(-pi/2);
                pos2 = robot.model.fkine(qMatrix(i, :)) * transl(0, 0.0127, 0.05) * troty(-pi/2);
                g1.model.base = pos1;
                g2.model.base = pos2;
                g1.model.animate(g1.model.getpos());
                g2.model.animate(g2.model.getpos());
        
                % Animate gripper opening/closing if required.
                if grip == 1 || grip == 2
                    g1.model.animate(qPath1(i, :));
                    g2.model.animate(qPath2(i, :));
                end
        
                % Update payload vertices if the robot is holding the object.
                if pickUp
                    updated_transform = robot.model.fkine(qMatrix(i, :)) * transl(0, 0, 0.2);
                    updated_vertices = [vertices, ones(size(vertices, 1), 1)] * updated_transform';
                    set(object, 'Vertices', updated_vertices(:, 1:3));
                end
        
                drawnow();
            end
        
            % Return the final joint configuration.
            qEnd = qMatrix(end, :);
        end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        %% Robot Movement
        function qEnd = MoveRobot(robot,position,steps,payload,holdingObject, vertices, endEffDirection,g_1,g_2,grip,cow)
            % move end effector to specified location and carry bricks if required
            % Obtain robots current position and desired position to form qMatrix

            %% Set eStop bool to false
            StoreSwitchButtons.setgeteStop(false);
            StoreSwitchButtons.setgetManual(false);
            StoreSwitchButtons.setgetCow(false);

            robotcount = 1;
            
            % forced cow collision
            [Y,X] = meshgrid(-0.2:0.1:0.2,-0.4:0.1:0.4);
            sizeMat = size(X);
            Z = repmat(0.25,sizeMat(1),sizeMat(2));
            % oneSideOfCube_h = surf(X,Y,Z);
            % Combine one surface as a point cloud
            cubePoints = [X(:),Y(:),Z(:)];
            % Make a cube by rotating the single side by 0,90,180,270, and around y to make the top and bottom faces
            cubePoints = [ cubePoints ...
                ; cubePoints * rotx(pi/2)...
                ; cubePoints * rotx(pi) ...
                ; cubePoints * rotx(3*pi/2) ...
                ; cubePoints * roty(pi/2) ...
                ; cubePoints * roty(-pi/2)];

            cubePoints = cubePoints + repmat([-1,-.7,-0.2],size(cubePoints,1),1);


            if (endEffDirection == 1)
                endMove = transl(position) * trotx(-pi/2); % To position end effector point in towards y axis in positive direction
            elseif (endEffDirection == 2)
                endMove = transl(position) * trotx(pi); % To position end effector to point towards z axis in negative direction
            elseif (endEffDirection == 3)
                endMove = transl(position) * trotx(pi/2); % To position end effector point in towards y axis in negative direction
            else
                endMove = transl(position) * troty(-pi/2); % To position end effector to point towards x axis in negative direction
            end

            q0 = robot.model.getpos();
            pose = robot.model.fkine(q0);
            q1 = robot.model.ikcon(pose, q0);
            q2 = robot.model.ikcon(endMove, q0);
            
            % Initalise collision functions for use
            collF = CollisionFunctions();
            
            % Method 2 Trapezoidal Velocity Profile - linear interpolation between points
            s = lspb(0,1,steps);  % First, create the scalar function
            qMatrix = nan(steps,length(robot.model.links));  % Create memory allocation for variables
            for i = 1:steps
                qMatrix(i,:) = (1-s(i))*q1 + s(i)*q2;
            end
        
            % If gripper is required to open or close, perform calculation.
            if grip == 1 || grip == 2 % grip == 0 means remain as is.

                % Open and close state set at +/- 10 degrees after initial
                % close (See GripperMove fucntion)
                leftQopen = [deg2rad(-20),deg2rad(20),0];
                rightQopen = [deg2rad(20),deg2rad(-20),0];
                leftQclosed = [deg2rad(-30),deg2rad(30),0];
                rightQclosed = [deg2rad(30),deg2rad(-30),0];

                if grip == 1
                    % Close Gripper
                    qPath1 = jtraj(rightQopen,rightQclosed,steps);
                    qPath2 = jtraj(leftQopen,leftQclosed,steps);
                elseif grip == 2
                    % Open Gripper
                    qPath1 = jtraj(rightQclosed,rightQopen,steps);
                    qPath2 = jtraj(leftQclosed,leftQopen,steps);
                end
            end

            % Execute the motion
            i = 1;
            sidesteps = 10;
                while i < steps
                    

                    if StoreSwitchButtons.setgetCow() == 1
                        cow.model.base = transl(1, -.5, 0.01);
                        cow.model.animate(cow.model.getpos());
                        drawnow;
                        cowCheck = collF.lightcurtainCheck(cow);
                        if cowCheck == true
                            StoreSwitchButtons.setgeteStop(true);
                            StoreSwitchButtons.setgetCow(true);
                        end
                        StoreSwitchButtons.setgetCow(false);
                    end



                    %Check estop at each step
                    [eStopValue, ~] = RobotFunctions.Check_eStop(StoreSwitchButtons.setgeteStop,StoreSwitchButtons.setgetManual, StoreSwitchButtons.setgetCow);

                    if eStopValue == true

                        % if eStop is true save Q values of each robot
                        Bot_pos = robot.model.getpos();
                        Grip1_pos = g_1.model.getpos();
                        Grip2_pos = g_2.model.getpos();

                        StopQs = [Bot_pos Grip1_pos Grip2_pos]; %Set stopQ container to store q values of each bot row 1 [robot, grip1, grip2] row 2 [robot2, grip3, grip 4]

                        RobotFunctions.eStop(StopQs,robotcount,cow); %robot,Harvest_pos,g_1,Grip1_pos,g_2,Grip2_pos,robot2,Panda_pos,g_3,Grip3_pos,g_4,Grip4_pos

                        disp ('Stop success, Return to loop')
                    else

                    end

                    cowCheck = collF.collisionCheckCow(robot, cow);
                    % To check for collisions against self and ground
                    if strcmp(robot.plyFileNameStem, 'BabyCow')
                        groundCheck = 2;
                    else
                        groundCheck = collF.collisionGroundLPI(robot);
                    end
                    selfCheck = collF.collisionCheckSelf(robot, qMatrix(i, :));

                    % Animation of Robot
                    robot.model.animate(qMatrix(i,:));

                    % Gripper base transform for UR3.
                    pos1 = robot.model.fkineUTS(robot.model.getpos())*transl(0,-0.0127,0.05)*troty(-pi/2);%z0.0612
                    pos2 = robot.model.fkineUTS(robot.model.getpos())*transl(0,0.0127,0.05)*troty(-pi/2);%z0.0612

                    
                    g_1.model.base = pos1; 
                    g_2.model.base = pos2; 
                    g_1.model.animate(g_1.model.getpos());
                    g_2.model.animate(g_2.model.getpos());

                    if grip == 1 || grip == 2
                        % Gripper open or close if necessary
                        g_1.model.animate(qPath1(i,:));
                        g_2.model.animate(qPath2(i,:));  
                    end

                    % Apply transformation to objects vertices to visualise movement
                    if holdingObject
                        transMatrix = robot.model.fkine(qMatrix(i,:)).T; % create transformation matrix of current end effector position
                        transMatrix = transMatrix*transl(0,0,0.2); % Manipulate translation matrix to offset object from end effector
                        transfromedVert = [vertices,ones(size(vertices,1),1)] * transMatrix'; % transform vertices of object at origin position by transformation matrix
                        set(payload,'Vertices',transfromedVert(:,1:3));
                    end

                    
                    drawnow();
                    if i < 5
                            disp('giving time to move')
                            drawnow();
                            i = i+1;
                            continue
                    end
                    if cowCheck || selfCheck || groundCheck == 1 
                        disp('(potential) Collision! Avoiding...')
                        poseNow = robot.model.getpos();
                        pointNow = robot.model.fkine(poseNow).T;

                        poseA = robot.model.getpos();
                        pointA = robot.model.fkineUTS(qMatrix(i-1, :));
                        pointNext = robot.model.fkineUTS(qMatrix(i,:));
                        pointAvec = pointA(1:3, 4);
                        nextpointAvec = pointNext(1:3, 4);
                        targetVec = [nextpointAvec(1)-pointAvec(1), nextpointAvec(2)-pointAvec(2), nextpointAvec(3)-pointAvec(3)];
                        magn = norm(targetVec);
                        normalisedTarg = targetVec/magn;
                        targetDist = -1;
                        newPoint = [pointAvec(1)+targetDist*normalisedTarg(1), pointAvec(2)+targetDist*normalisedTarg(2), 1+pointAvec(3)+targetDist*normalisedTarg(3)];
                        if groundCheck == 1
                            newPoint =[pointAvec(1)+targetDist*normalisedTarg(1), pointAvec(2)+targetDist*normalisedTarg(2), pointAvec(3)+targetDist*normalisedTarg(3)+1.4];
                        end
                        %                         avoidPointB = pointB*inv(poseBnext)*(pointB) * transl(-.01,-.01, 0)*trotz(-pi/10);
                        if isrow(newPoint)
                            newPoint = newPoint';
                        end
                        newPoint = [newPoint; 1];
                        randRot = trotz((rand()-.5)*pi/12)*trotx((rand()-.5)*pi/12);
                        pointA = pointA*randRot;
                        pointAvoid = [pointA(:, 1:3), newPoint];
                        poseAvoid = robot.model.ikcon(pointAvoid, poseA);
                        s1 = lspb(0,1,sidesteps);
                        firstqMatrix = (1-s1)*poseA + s1*poseAvoid;
                        s2 = lspb(0,1, steps - sidesteps); 
                        secondqMatrix = (1-s2)*firstqMatrix(sidesteps, :) + s2*q2;
                        qMatrix = [firstqMatrix; secondqMatrix];
                        i = 1;
                        drawnow();
                        continue;
                    end
                    i = i + 1;
                end
            
            end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function qEnd = MoveRobot(robot, pose, steps, object, vertices, pickUp, endEffDirection, g1, g2)
            % MoveRobot Moves a robot to a specified position and operates the gripper.
            %
            % Inputs:
            %   - robot: The robot model.
            %   - pose: Desired end-effector pose.
            %   - steps: Number of steps for the trajectory.
            %   - object: The graphical object to update.
            %   - vertices: Vertices of the object.
            %   - pickUp: Boolean, true if the robot is to pick up the object.
            %   - endEffDirection: 'left', 'right', 'forward', or 'down'.
            %   - g1, g2: Gripper models.
            %
            % Outputs:
            %   - qEnd: Final joint configuration.
        
            % Determine the end-effector pose based on direction.
            switch lower(endEffDirection)
                case 'left'
                    endMove = transl(pose) * troty(pi/2);
                case 'right'
                    endMove = transl(pose) * troty(-pi/2);
                case 'forward'
                    endMove = transl(pose);
                case 'down'
                    endMove = transl(pose) * trotx(pi);
                otherwise
                    error('Invalid endEffDirection. Use "left", "right", "forward", or "down".');
            end

            collision = CollisionClass();
        
            % Calculate the initial and target joint configurations.
            q0 = robot.model.getpos();
            q1 = robot.model.ikcon(robot.model.fkine(q0), q0);
            q2 = robot.model.ikcon(endMove, q0);
        
            % Generate trajectory using trapezoidal velocity profile.
            s = lspb(0, 1, steps);
            qMatrix = nan(steps,length(robot.model.links));  % Create memory allocation for variables
            for i = 1:steps
                qMatrix(i,:) = (1-s(i))*q1 + s(i)*q2;
            end
        
            % Set up gripper trajectory for pick up if needed.
            if pickUp
                qPath1 = jtraj([0, 0, 0], [deg2rad(30), -deg2rad(30), 0], steps);  % Close for pick-up.
                qPath2 = jtraj([0, 0, 0], [-deg2rad(30), deg2rad(30), 0], steps);
            end
        
            % Execute the motion and animate the robot and grippers.
            for i = 1:steps
                robot.model.animate(qMatrix(i, :));
        
                % Update gripper positions.
                pos1 = robot.model.fkineUTS(qMatrix(i, :)) * transl(0, -0.0127, 0.05) * troty(-pi/2);
                pos2 = robot.model.fkineUTS(qMatrix(i, :)) * transl(0, 0.0127, 0.05) * troty(-pi/2);
                g1.model.base = pos1;
                g2.model.base = pos2;
                g1.model.animate(g1.model.getpos());
                g2.model.animate(g2.model.getpos());
        
                % Animate gripper if picking up.
                if pickUp
                    g1.model.animate(qPath1(i, :));
                    g2.model.animate(qPath2(i, :));
        
                    % Update payload vertices to reflect its transformation.
                    updated_transform = robot.model.fkine(qMatrix(i, :)).T * transl(0, 0, 0.2);
                    updated_vertices = [vertices, ones(size(vertices, 1), 1)] * updated_transform';
                    set(object, 'Vertices', updated_vertices(:, 1:3));
                end
        
                drawnow();
            end
        
            % Return the final joint configuration.
            qEnd = qMatrix(end, :);
        end