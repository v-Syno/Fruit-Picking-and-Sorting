function qEnd = MoveRobot2(robot,pose,steps,payload,vertices, holdingObject, endEffDirection,g1,g2,grip)

            switch lower(endEffDirection)
                case 'forward'
                    T_EE = transl(pose) * trotx(-pi/2);
                case 'backwards'
                    T_EE = transl(pose) * trotx(pi/2);
                case 'down'
                    T_EE = transl(pose) * trotx(pi);
                case 'up'
                    T_EE = transl(pose);
            end

            q0 = robot.model.getpos();
            position = robot.model.fkine(q0);
            q1 = robot.model.ikcon(position, q0);
            qEnd = robot.model.ikcon(T_EE, q0);
            
            % Initalise collision functions for use
            collF = CollisionClass();


            % Method 2 Trapezoidal Velocity Profile - linear interpolation between points
            s = lspb(0,1,steps);  % First, create the scalar function
            qMatrix = nan(steps,length(robot.model.links));  % Create memory allocation for variables
            for i = 1:steps
                qMatrix(i,:) = (1-s(i))*q1 + s(i)*qEnd;
            end
        
            % If gripper is required to open or close, perform calculation.
            if grip == 1 || grip == 2 % grip == 0 means remain as is.

                % Open and close state set at +/- 10 degrees after initial
                % close (See GripperMove fucntion)
                leftQopen = [deg2rad(-20),deg2rad(20),0];
                rightQopen = [deg2rad(20),deg2rad(-20),0];
                leftQclosed = [deg2rad(-30),deg2rad(30),0];
                rightQclosed = [deg2rad(30),deg2rad(-30),0];

                if grip == 1
                    % Close Gripper
                    qPath1 = jtraj(rightQopen,rightQclosed,steps);
                    qPath2 = jtraj(leftQopen,leftQclosed,steps);
                elseif grip == 2
                    % Open Gripper
                    qPath1 = jtraj(rightQclosed,rightQopen,steps);
                    qPath2 = jtraj(leftQclosed,leftQopen,steps);
                end
            end

            % Execute the motion
            i = 1;
            sidesteps = 10;
                while i < steps

                    groundCheck = collF.collisionGroundLPI(robot);

                    selfCheck = collF.collisionCheckSelf(robot, qMatrix(i, :));

                    % Animation of Robot
                    robot.model.animate(qMatrix(i,:));

                    % Gripper base transform for UR3.
                    pos1 = robot.model.fkineUTS(robot.model.getpos())*transl(0,-0.0127,0.05)*troty(-pi/2);%z0.0612
                    pos2 = robot.model.fkineUTS(robot.model.getpos())*transl(0,0.0127,0.05)*troty(-pi/2);%z0.0612

                    
                    g1.model.base = pos1; 
                    g2.model.base = pos2; 
                    g1.model.animate(g1.model.getpos());
                    g2.model.animate(g2.model.getpos());

                    if grip == 1 || grip == 2
                        % Gripper open or close if necessary
                        g1.model.animate(qPath1(i,:));
                        g2.model.animate(qPath2(i,:));  
                    end

                    % Apply transformation to objects vertices to visualise movement
                    if holdingObject
                        transMatrix = robot.model.fkine(qMatrix(i,:)).T; % create transformation matrix of current end effector position
                        transMatrix = transMatrix*transl(0,0,0.2); % Manipulate translation matrix to offset object from end effector
                        transfromedVert = [vertices,ones(size(vertices,1),1)] * transMatrix'; % transform vertices of object at origin position by transformation matrix
                        set(payload,'Vertices',transfromedVert(:,1:3));
                    end

                    
                    drawnow();
                    if i < 5
                            disp('giving time to move')
                            drawnow();
                            i = i+1;
                            continue
                    end
                    if selfCheck || groundCheck == 1 
                        disp('(potential) Collision! Avoiding...')
                        poseNow = robot.model.getpos();
                        pointNow = robot.model.fkine(poseNow).T;
                        poseA = robot.model.getpos();
                        pointA = robot.model.fkineUTS(qMatrix(i-1, :));
                        pointNext = robot.model.fkineUTS(qMatrix(i,:));
                        pointAvec = pointA(1:3, 4);
                        nextpointAvec = pointNext(1:3, 4);
                        targetVec = [nextpointAvec(1)-pointAvec(1), nextpointAvec(2)-pointAvec(2), nextpointAvec(3)-pointAvec(3)];
                        magn = norm(targetVec);
                        normalisedTarg = targetVec/magn;
                        targetDist = -1;
                        newPoint = [pointAvec(1)+targetDist*normalisedTarg(1), pointAvec(2)+targetDist*normalisedTarg(2), 1+pointAvec(3)+targetDist*normalisedTarg(3)];
                        if groundCheck == 1
                            newPoint =[pointAvec(1)+targetDist*normalisedTarg(1), pointAvec(2)+targetDist*normalisedTarg(2), pointAvec(3)+targetDist*normalisedTarg(3)+1.4];
                        end
                        if isrow(newPoint)
                            newPoint = newPoint';
                        end
                        newPoint = [newPoint; 1];
                        randRot = trotz((rand()-.5)*pi/12)*trotx((rand()-.5)*pi/12);
                        pointA = pointA*randRot;
                        pointAvoid = [pointA(:, 1:3), newPoint];
                        poseAvoid = robot.model.ikcon(pointAvoid, poseA);
                        s1 = lspb(0,1,sidesteps);
                        firstqMatrix = (1-s1)*poseA + s1*poseAvoid;
                        s2 = lspb(0,1, steps - sidesteps); 
                        secondqMatrix = (1-s2)*firstqMatrix(sidesteps, :) + s2*qEnd;
                        qMatrix = [firstqMatrix; secondqMatrix];
                        i = 1;
                        drawnow();
                        continue;
                    end
                    i = i + 1;
                end
            end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% RobotClass
classdef RobotClass
    % Class for Robot functions

    methods (Static)

        function qGoal = MoveObject(robot, pose, steps, object, vertices, pickUp)
            % MoveObject2 Moves a robot to a specified pose
            % 
            % Inputs:
            %   - robot: The robot model.
            %   - pose: Desired end-effector pose
            %   - steps: Number of steps for the trajectory.
            %   - object: The graphical object to update.
            %   - vertices: Vertices of the object.
            %   - pickUp: Boolean indicating if the robot is holding the object.
            %
            % Outputs:
            %   - qGoal: Final joint configuration.
            
        
            q0 = robot.model.getpos(); % Get current joint poses
            T_EE = transl(pose)* trotx(pi); % Using the provided end-effector pose
            qGoal = robot.model.ikcon(T_EE, q0); % Compute joint configuration for the goal
        
            qMatrix = jtraj(q0,qGoal,steps);

            % Execute the motion
            for i = 1:steps
                robot.model.animate(qMatrix(i, :));
        
                if pickUp
                    % Update the object's vertices to reflect its transformation
                    updated_transform = robot.model.fkineUTS(qMatrix(i, :));
                    updated_vertices = [vertices, ones(size(vertices, 1), 1)] * updated_transform';
                    set(object, 'Vertices', updated_vertices(:, 1:3));
                end
                drawnow();
            end
        
            qGoal = qMatrix(end, :);
        end

        function qGoal = MoveRobot(robot, pose, steps, payload, vertices, holdingObject, endEffDirection)
            % Setup the end-effector transformation based on the direction.
            T_EE = getEndEffectorTransform(pose, endEffDirection);
        
            % Get initial and goal joint configurations.
            q0 = robot.model.getpos();
            qGoal = robot.model.ikcon(T_EE, q0);
            
            % Generate a smoother joint trajectory using `jtraj`.
            qMatrix = jtraj(q0, qGoal, steps);
            
            % Initialize collision functions.
            collF = CollisionClass();
            i = 1;
            sidesteps = 30;
        
            % Iterate through the trajectory steps.
            while i <= steps
                % Check for collisions.
                groundCheck = collF.collisionGroundLPI(robot);
                selfCheck = collF.collisionCheckSelf(robot, qMatrix(i, :));
                
                % If a collision is detected, adjust the path.
                if groundCheck == 1 || selfCheck
                    disp('(potential) Collision! Adjusting path...');
                    qMatrix = adjustPath(robot, qMatrix, i, sidesteps, qGoal, groundCheck);
                    i = 1; % Restart the loop with the new path.
                    continue;
                end
        
                % Animate the robot.
                robot.model.animate(qMatrix(i, :));
                
                % Update object position if holding.
                if holdingObject
                    updateObjectPosition(robot, qMatrix(i, :), payload, vertices);
                end
        
                drawnow();
                i = i + 1;
            end
        end

        function GripperMove(right, left, state)
            % Controls the opening or closing of the gripper.
            steps = 50; % Number of steps for smoother transition.
            
            % Define angles for open/closed states.
            leftQopen = [deg2rad(-20), deg2rad(20), 0];
            rightQopen = [deg2rad(20), deg2rad(-20), 0];
            leftQclosed = [deg2rad(-30), deg2rad(30), 0];
            rightQclosed = [deg2rad(30), deg2rad(-30), 0];
        
            if strcmp(state, 'close')
                qPath1 = jtraj(rightQopen, rightQclosed, steps);
                qPath2 = jtraj(leftQopen, leftQclosed, steps);
            elseif strcmp(state, 'open')
                qPath1 = jtraj(rightQclosed, rightQopen, steps);
                qPath2 = jtraj(leftQclosed, leftQopen, steps);
            end
        
            % Animate the gripper.
            for i = 1:steps
                right.model.animate(qPath1(i, :));
                left.model.animate(qPath2(i, :));
                drawnow();
            end
        end

        function T_EE = getEndEffectorTransform(pose, direction)
            switch lower(direction)
                case 'forward'
                    T_EE = transl(pose) * trotx(-pi/2);
                case 'backwards'
                    T_EE = transl(pose) * trotx(pi/2);
                case 'down'
                    T_EE = transl(pose) * trotx(pi);
                case 'up'
                    T_EE = transl(pose);
                otherwise
                    error('Invalid end-effector direction');
            end
        end

        function updateObjectPosition(robot, qConfig, payload, vertices)
            % Compute the transformation matrix for the end-effector.
            transMatrix = robot.model.fkineUTS(qConfig) * transl(0, 0, 0.2);
            
            % Transform object vertices.
            transformedVertices = [vertices, ones(size(vertices, 1), 1)] * transMatrix';
            set(payload, 'Vertices', transformedVertices(:, 1:3));
        end

        function qMatrix = adjustPath(robot, qMatrix, currentIndex, sidesteps, qEnd, groundCheck)
            % Get the current and next points in the trajectory.
            poseNow = robot.model.getpos();
            pointNow = robot.model.fkineUTS(poseNow);
            pointNext = robot.model.fkineUTS(qMatrix(currentIndex, :));
            
            % Calculate the adjustment direction.
            targetVec = pointNext(1:3, 4) - pointNow(1:3, 4);
            normalizedTarget = targetVec / norm(targetVec);
            targetDist = -0.1; % Step back distance.
        
            % Calculate the new adjustment point.
            newPoint = pointNow(1:3, 4) + targetDist * normalizedTarget;
            if groundCheck == 1
                newPoint(3) = newPoint(3) + 0.2; % Raise if colliding with ground.
            end
            
            % Find the adjusted pose and generate a new trajectory.
            poseAvoid = robot.model.ikcon(transl(newPoint), poseNow);
            firstqMatrix = jtraj(poseNow, poseAvoid, sidesteps);
            secondqMatrix = jtraj(poseAvoid, qEnd, size(qMatrix, 1) - sidesteps);
            qMatrix = [firstqMatrix; secondqMatrix];
        end

        function [gripTransform1, gripTransform2] = getGripperTransforms(robot)
            eeTransform = robot.model.fkineUTS(robot.model.getpos());
            
            if strcmp(robot.plyFileNameStem, 'ColouredPanda')
                gripTransform1 = eeTransform * transl(0, -0.0127, 0.05) * troty(-pi/2);
                gripTransform2 = eeTransform * transl(0, 0.0127, 0.05) * troty(-pi/2);
            elseif strcmp(robot.plyFileNameStem, 'LinearUR3e')
                gripTransform1 = eeTransform * transl(0, 0.0127, 0.05) * troty(-pi/2);
                gripTransform2 = eeTransform * transl(0, -0.0127, 0.05) * troty(-pi/2);
            else
                error('Unsupported robot type.');
            end
        end


    end
end